<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>General Primer</title>
</head><body>Also see the downloaded "The GWT-RPC Wire Protocol" pdf<b><br/>
</b><b><br/>
</b><b>What is it?</b><br/>
Open source Java framework used to create Rich Internet Applications. <br/>
Both server and front-end are written in Java.<br/>
Java-to-Javascript compiler.<br/>
<br/>
<b>Benefits</b><br/>
Code re-use between server and client<br/>
Provides Remote Procedure Call (RPC) mechanism for client-server communication<br/>
Complex and visually appealing front-ends without the cross-browser headaches<br/>
Lots of widgets and extensions freely available<br/>
No browser plugin required<br/>
<br/>
<b>GWT Generated Files<br/>
</b><b>Note: </b>The "linker" (which is the last step in the compilation process, and is pluggable) was set by default to "std" (also known as IframeLinker) prior to GWT 2.7 and it produced *.cache.html files; starting with GWT 2.7, the default linker is "xsiframe" (aka CrossSiteIframeLinker) and it produces *.cache.js files.<b><br/>
</b><br/>
{Entrypoint}.nocache.js&#09;&#09;&#09;Detects browser and loads the corresponding {HEX}.cache.html file<br/>
{HEX}.cache.html&#09;&#09;&#09;&#09;Program logic of the application<br/>
{HEX}.gwt.rpc&#09;&#09;&#09;&#09;&#09;Types that are serialized in RPC requests<br/>
Note: {HEX} values are dynamically generated upon compilation<br/>
Note: Each {HEX}.cache.html is browser specific<br/>
<br/>
These are the important files produced by the GWT Compiler:<br/>
&nbsp; &nbsp; &lt;Module Name&gt;.nocache.js (or &lt;Module Name&gt;-xs.nocache.js for cross-site script inclusion)<br/>
&nbsp; &nbsp; &lt;Alphanumeric&gt;.cache.html<br/>
&nbsp; &nbsp; &lt;Alphanumeric&gt;.gwt.rpc<br/>
<br/>
Before explaining what each file does, it's useful to summarize the overall bootstrap procedure for a GWT application:<br/>
<br/>
&nbsp; &nbsp; The browser loads and processes the host HTML page.<br/>
&nbsp; &nbsp; When the browser encounters the page's &lt;script src="&lt;Module Name&gt;.nocache.js"&gt; tag, it immediately downloads and executes the JavaScript code in the file.<br/>
&nbsp; &nbsp; The .nocache.js file contains JavaScript code that resolves the Deferred Binding configurations (such as browser detection, for instance) and then uses a lookup table generated by the GWT Compiler to locate one of the .cache.html files to use.<br/>
&nbsp; &nbsp; The JavaScript code in .nocache.js then creates a hidden &lt;iframe&gt;, inserts it to the host page's DOM, and loads the .cache.html file into that iframe.<br/>
&nbsp; &nbsp; The .cache.html file contains the actual program logic of the GWT application.<br/>
<br/>
That's the process in a nutshell.<br/>
<br/>
<b>The .nocache.js File<br/>
</b>The "nocache" file is where <a href="http://code.google.com/support/bin/answer.py?answer=59657&topic=13006">Deferred Binding</a>&nbsp;occurs. Before the application can run, any dynamically-bound code must be resolved. One of the key features of the "nocache.js" file is a lookup table that maps Deferred Binding permutations to .cache.html filenames.<br/>
<br/>
What is Deferred Binding?<br/>
Deferred Binding is the Google Web Toolkit answer to Java reflection.<br/>
Because dynamic binding is unavailable as a technique to GWT, GWT instead uses deferred binding. &nbsp;One way to think of this is as "dynamic class-loading that occurs at compile time instead of execution time." &nbsp;When the GWT Compiler compiles your Java application, it determines all the different "idiosyncrasies" that it must support, and generates a separate, tightly streamlined version of the application for that specific configuration. &nbsp;For example, it generates a different version of the application file for Firefox than it does for Opera.<br/>
<br/>
<b>The .cache.html Files</b><br/>
The "cache" files contain your application's logic. If you were to look inside a .cache.html file, you would see that it is JavaScript code wrapped in a thin HTML wrapper. The .cache.html files are named according to the MD5 sum of their contents.<br/>
<br/>
<b>The .gwt.rpc Files</b><br/>
In previous versions of GWT, if your application used GWT RPC, the types that you wanted to serialize across the wire had to implement the IsSerializable interface. In GWT 1.4, types that implement the java.io.Serializable interface now also qualify for serialization over RPC, with some conditions.<br/>
<br/>
One of these conditions is that the types that you would like to serialize over the wire must be included in the .gwt.rpc file generated by the GWT compiler. The .gwt.rpc file serves as a serialization policy to indicate which types implementing java.io.Serializable are allowed to be serialized over the wire<br/>
<br/>
<b>Client side code is delivered to the user</b><br/>
Javascript code is protected with obfuscation<br/>
Contains valuable information<ul><li>GWT-RPC service endpoints</li>
<li>Custom object structures</li>
<li>Restricted or hidden UI functionality</li>
</ul>
<br/>
<b>GWT RPC Interface</b><br/>
Built-in Remote Procedure Call (RPC) framework<br/>
Uses a serialization protocol to call remote methods and also send Java data types and objects as parameters from client to server.<br/>
GWT RPC methods return values serialized using JSON<br/>
<br/>
<br/>
</body></html>