<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>General Primer</title>
</head><body>To understand what we're going to show it's necessary to become familiar with some concepts. The first thing we need to know is what are Unmanaged code and Managed code and how they differ.<br/>
<br/>
<b>Unmanaged code</b><br/>
When we execute a binary in native C/C++, we are working with unmanaged code. This kind of code has the peculiarity it's just get loaded in memory by the OS and gets executed. Everything else depends on the guy who coded the program.<br/>
<br/>
What is "everything else"? Things like memory management or security checks. For example, if a buffer overflow exists in X function is your problem my friend.<br/>
<br/>
<b>Managed code</b><br/>
In contrast with unmanaged, we are working with managed code when we program something using the .NET Framework. The basic difference it's just that .NET offers an enviroment in execution time called Common Language Runtime (CLR). The CLR will compile and execute our managed code even taking care of things like managing memory, perform security checks and so on.<br/>
<br/>
Well, among other things, the CLR offers us the opportunity to use something called Profiling<br/>
<br/>
<b>Profiling</b><br/>
In the profiling context, a profiler is kind of a form of dynamic program analysis that measures thinkgs like the space or time complexity of a program. A CLR profiler is in fact a runtime DLL library loaded by the CLR with which it communicates through an API<br/>
<br/>
So when a managed process is started, the CLR will check if any of the profiler env variables are set and if so, load the specified profiler DLL. (Kind of like LD_PRELOAD in Linux!)<br/>
<br/>
<b>COR_ENABLE_PROFILING</b>&nbsp;--&gt; 1 to enable the profiler, 0 to disable.<br/>
<b>COR_PROFILER</b>&nbsp;--&gt; If COR_ENABLE_PROFILING is 1 then CLR check the CLSID/ProgID of the profiler.<br/>
<b>COR_PROFILER_PATH</b>&nbsp;--&gt; Path to the profiler's DLL.<br/>
<br/>
As a curiosity, in the .bat for users "not admin" of Invisi-Shell, instead of using COR_PROFILER_PATH, a series of entries in the registry HKCU are created. This is not necessary for the latest versions of NET.<br/>
<br/>
More info:<br/>
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview<br/>
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/setting-up-a-profiling-environment<br/>
<br/>
<br/>
<br/>
</body></html>